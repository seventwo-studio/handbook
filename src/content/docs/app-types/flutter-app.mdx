---
title: Flutter App Standards
---

## Overview

Flutter is used at SevenTwo Studio for cross-platform mobile applications when we're not using Expo. Flutter provides native performance on iOS and Android with a single codebase. Our Flutter standards emphasize reactive state management, widget composition, and platform-appropriate design.

## State Management

We use Riverpod and Bloc for state management. Riverpod provides compile-time safe dependency injection and reactive state management with minimal boilerplate. Bloc implements the BLoC (Business Logic Component) pattern, separating business logic from UI and making state changes predictable and testable.

Riverpod is preferred for simpler state management needs and dependency injection, while Bloc is used for complex state machines and when explicit event-driven architecture is beneficial.

## Architecture

We follow platform-specific architecture patterns that align with Bloc or MVVM principles. ViewModels or BLoCs manage state and business logic, while widgets remain presentation-focused. This separation improves testability and makes the codebase more maintainable.

## Widget Organization

We organize widgets into small, composable pieces rather than large monolithic widgets. Each widget should have a single responsibility. We extract reusable widgets into separate files and use folders with index files for complex components.

Widget files are co-located with their tests and any widget-specific assets or styles. This keeps related code together and makes features self-contained.

## Navigation

We use platform-appropriate navigation patterns. Flutter's Navigator 2.0 provides declarative routing with type-safe navigation arguments. We centralize navigation logic to make routing testable and maintainable.

## Platform-Specific Code

We handle platform-specific code through platform channels and conditional imports. Platform channels enable communication with native iOS and Android code when Flutter doesn't provide needed functionality. Conditional imports allow different implementations for iOS and Android when behavior needs to diverge.

We minimize platform-specific code, preferring Flutter's cross-platform widgets and packages when possible. When platform-specific code is necessary, we encapsulate it behind unified interfaces.

## Offline-First Functionality

We implement offline-first functionality using local databases with background sync. This ensures the app remains functional without network connectivity. We use SQLite or Hive for local storage and sync changes when connectivity is restored.

## Testing

We use Flutter's built-in testing framework for unit tests, widget tests, and integration tests. Widget tests verify UI behavior, while integration tests validate complete user flows. We maintain minimum 80% code coverage and practice TDD.

Platform-specific tests verify behavior on both iOS and Android. We test edge cases like network failures, state restoration, and platform-specific behaviors.

## Styling and Theming

We implement comprehensive theming using Flutter's ThemeData. Themes define colors, typography, and component styles consistently across the app. We support both light and dark themes and respect system theme preferences.

## Dependency Management

We use Flutter's built-in pub package manager for dependencies. The `pubspec.yaml` file defines all dependencies and constraints. We keep dependencies up to date using automated dependency updates.

## Code Style

We follow Flutter and Dart conventions enforced by the Dart analyzer and formatter. Code is formatted with 2-space indentation. The formatter runs automatically in pre-commit hooks.

## Performance

We optimize performance through widget rebuilding optimization, image caching, and lazy loading. We use const constructors wherever possible to avoid unnecessary rebuilds. We profile the app regularly to identify and fix performance bottlenecks.

## Rules

### Framework

1. Use Flutter for cross-platform mobile apps (alternative to Expo)

### State Management

2. Use Riverpod for state management and dependency injection
3. Use Bloc for complex state machines and event-driven architecture
4. Prefer Riverpod for simpler state needs

### Architecture

5. Follow Bloc or MVVM architecture patterns
6. Separate business logic from UI in ViewModels or BLoCs

### Widget Organization

7. Organize widgets into small, composable pieces
8. Extract reusable widgets into separate files
9. Co-locate widget files with tests and assets

### Navigation

10. Use Navigator 2.0 for declarative routing
11. Centralize navigation logic for testability

### Platform-Specific Code

12. Handle platform-specific code through platform channels
13. Use conditional imports for platform-divergent behavior
14. Minimize platform-specific code - prefer cross-platform solutions
15. Encapsulate platform-specific code behind unified interfaces

### Offline Support

16. Implement offline-first functionality with local database and sync
17. Use SQLite or Hive for local storage
18. Sync changes in background when connectivity restored

### Testing

19. Use Flutter's built-in testing framework
20. Write unit tests, widget tests, and integration tests
21. Minimum 80% code coverage required
22. Practice Test-Driven Development (TDD) strictly
23. Test on both iOS and Android platforms
24. Test edge cases: network failures, state restoration, platform behaviors
25. Tests required for all new features and bug fixes

### Theming

26. Implement comprehensive theming with ThemeData
27. Support light and dark themes
28. Respect system theme preferences

### Dependencies

29. Use pub package manager for dependencies
30. Keep dependencies up to date with automated updates

### Code Style

31. Follow Flutter and Dart conventions
32. Use Dart analyzer and formatter for code style
33. 2-space indentation required
34. Run formatter in pre-commit hooks

### Performance

35. Optimize widget rebuilding with const constructors
36. Implement image caching
37. Use lazy loading for lists and heavy content
38. Profile app regularly for performance bottlenecks

### Naming Conventions

39. Use snake_case for variables and functions
40. Use PascalCase for classes and widgets
41. Maximum function length is 50 lines
