---
title: Version Control Standards
---

## Overview

Version control is fundamental to SevenTwo Studio's development workflow. We use Git with GitHub for all code repositories, following GitHub Flow for branch management. Our version control standards ensure clean history, meaningful commits, and streamlined collaboration.

## Git Workflow

We follow GitHub Flow, a lightweight branch-based workflow. The main branch is always deployable. Feature development happens in feature branches that are merged through pull requests. This workflow is simple, supports continuous deployment, and scales well for teams of all sizes.

Feature branches are short-lived and focused on single features or fixes. We avoid long-running feature branches that diverge significantly from main, as they create complex merge conflicts and integration challenges.

## Branch Naming

Branch names follow the `issue-number/description` format. The issue number links the branch to its tracking issue, while the description provides context. Examples: `123/add-user-authentication`, `456/fix-login-bug`.

This convention makes branches easily traceable to their corresponding issues and provides clear context about the branch's purpose.

## Commit Messages

We use Conventional Commits format for all commit messages. Conventional Commits provide a standard structure that enables automatic changelog generation, semantic versioning, and clear commit history.

Commit messages follow the format: `type(scope): description`. Common types include:
- `feat`: New features
- `fix`: Bug fixes
- `docs`: Documentation changes
- `style`: Code style changes (formatting, whitespace)
- `refactor`: Code refactoring without behavior changes
- `test`: Test additions or modifications
- `chore`: Maintenance tasks

When commits relate to issues, we mention the issue number in the commit message. This creates traceable links between commits and issues.

## Commit Message Quality

Commit messages should be concise and focus on the "why" rather than the "what." The code diff shows what changed; the message explains why it changed and what problem it solves.

We write commit messages in the imperative mood: "Add feature" not "Added feature." This aligns with Git's own convention for generated commits.

## Commit Signing

All commits must be signed with GPG or SSH signatures. Signed commits verify the author's identity and prevent commit spoofing. GitHub displays verified badges on signed commits.

We configure Git to sign commits automatically and reject unsigned commits in CI. This ensures all commits in the repository are verified and trustworthy.

## Pre-Commit Hooks

We use Lefthook and native Git hooks for pre-commit checks. Pre-commit hooks run automatically before each commit, catching issues early in the development cycle.

Hooks run linting, formatting, type checking, and fast unit tests. This prevents committing code that fails basic quality checks. Hooks are configured in the repository and run consistently for all developers.

We never use `--no-verify` to bypass hooks. If hooks fail, we fix the issues rather than bypassing verification.

## Merging Strategy

We squash commits when merging pull requests. Squashing creates a clean, linear history with one commit per feature or fix. This makes git log readable and simplifies operations like bisecting or reverting changes.

The squashed commit message summarizes all changes in the pull request. We ensure the final commit message is clear and follows Conventional Commits format.

## Main Branch Protection

The main branch is protected and requires pull request reviews before merging. We cannot push directly to main. This ensures all code is reviewed and passes CI checks before integration.

Branch protection rules enforce:
- Pull request reviews from code owners
- Passing CI checks
- Up-to-date branches (resolved merge conflicts)
- Signed commits

## Pull Request Process

Pull requests are the mechanism for code review and integration. PRs must include clear descriptions, testing instructions, screenshots for UI changes, and links to related issues.

We use PR templates with checklists to ensure consistent, complete pull requests. Templates prompt authors to include necessary information and verify they've completed required steps.

## Code Review Response Time

We aim to respond to pull requests within 24 hours. Timely reviews prevent blocked work and maintain development momentum. Reviewers prioritize PRs to keep the team moving efficiently.

## Handling Breaking Changes

Breaking changes are clearly documented in commit messages and pull request descriptions. We use the `BREAKING CHANGE:` footer in commit messages to trigger major version bumps in semantic versioning.

Breaking changes are communicated to the team and coordinated to minimize disruption.

## Rules

### Git Workflow

1. Use Git with GitHub for all code repositories
2. Follow GitHub Flow for branch management
3. Main branch (named "main") is always deployable
4. Feature development happens in feature branches
5. Feature branches are short-lived and focused
6. Branch names follow issue-number/description format

### Commit Messages

7. Use Conventional Commits format for all commit messages
8. Commit types: feat, fix, docs, style, refactor, test, chore
9. Mention issue numbers in commit messages when applicable
10. Commit messages focus on "why" not "what"
11. Write commit messages in imperative mood
12. Each commit shall pertain to only one issue at a time

### Commit Signing

13. All commits must be GPG or SSH signed
14. Configure Git to sign commits automatically
15. Reject unsigned commits in CI

### Pre-Commit Hooks

16. Use Lefthook and native Git hooks for pre-commit checks
17. Run linting, formatting, type checking, and fast tests in pre-commit
18. Never use --no-verify to bypass hooks
19. Fix issues instead of bypassing verification

### Merging Strategy

20. Squash commits when merging pull requests
21. Create one commit per feature or fix through squashing
22. Ensure squashed commit messages follow Conventional Commits

### Main Branch Protection

23. Protect main branch - require PR reviews before merging
24. No direct pushes to main
25. Enforce PR reviews from code owners
26. Require passing CI checks before merge
27. Require up-to-date branches before merge
28. Require signed commits

### Pull Request Process

29. PRs must include clear descriptions and testing instructions
30. Include screenshots for UI changes in PRs
31. Link related issues in PR descriptions
32. Use PR templates with checklists
33. Respond to pull requests within 24 hours

### Breaking Changes

34. Clearly document breaking changes in commit messages
35. Use BREAKING CHANGE: footer for semantic versioning
36. Communicate breaking changes to the team

### History Management

37. Maintain clean, linear git history through squashing
38. Use git log to review project history
39. Auto-generate CHANGELOG from commit messages using [Release Please](/practices/release-strategy/)
