---
title: TypeScript Coding Standards
---

import { Aside, Badge, Tabs, TabItem, Code } from '@astrojs/starlight/components';

## Overview

TypeScript is the primary language for SevenTwo Studio's web and backend development. We enforce strict type safety to catch errors at compile time and improve code maintainability. Our TypeScript standards emphasize clarity, type correctness, and modern language features.

## Type Safety

We use TypeScript in strict mode with all strict flags enabled. This means we never compromise on type safety. The use of `any` is prohibited unless absolutely necessary and requires justification in code review. We prefer explicit typing and leverage TypeScript's type inference where appropriate.

:::caution[Never Bypass Type Safety]
We avoid type assertions and non-null assertions (`!`) as they bypass type safety. Instead, we handle nullability explicitly through proper type guards and optional chaining.
:::

When working with unions and intersections, we use discriminated unions to make type narrowing predictable and safe.

## Type Declarations

We prefer `interface` for object shapes and `type` for unions, intersections, and complex type compositions. This distinction helps maintain consistency across the codebase. Interfaces are extensible and work well with declaration merging, while type aliases are more flexible for complex type operations.

:::tip[Literal Types]
For literal values that should be immutable, we use `as const` assertions to preserve the exact literal types rather than widening to general types like `string` or `number`.
:::

## Enums

We use TypeScript enums for representing a fixed set of related constants. Enums provide type safety and prevent invalid values from being used. They're particularly useful for state machines, status codes, and configuration options.

## Function Declarations

We use arrow functions for callbacks and inline functions, while using traditional function declarations for named, top-level functions. This convention improves readability and makes the code's structure more apparent. Arrow functions also preserve lexical `this` binding, which is crucial in many scenarios.

## Testing

We use Jest as our primary testing framework for TypeScript code. Unit tests are required for all new code and bug fixes, with a minimum code coverage of 80%. We follow the Arrange-Act-Assert (AAA) pattern for test structure, making tests easy to read and understand.

:::note[Test Organization]
Tests live in a separate `/tests` directory and use the `*.test.ts` naming convention. We practice Test-Driven Development (TDD) strictly, writing tests before implementation.
:::

We use minimal mocking, preferring real implementations where possible. When mocking is necessary, we mock at boundaries (external APIs, databases) rather than internal functions.

## Error Handling

We use try-catch blocks with custom error classes for error handling. Domain-specific error classes help categorize errors and provide meaningful context. For async operations, we exclusively use try-catch with async/await rather than promise chains with `.catch()`.

:::tip[Error Messages]
Error messages are generic for users but detailed in logs. In development environments, we provide detailed error information to aid debugging, while production errors are sanitized to avoid leaking sensitive information.
:::

## Module Organization

We organize imports using auto-sorting tools, typically grouping external dependencies, internal modules, and relative imports. We use path aliases with the `@/` prefix for cleaner import statements and better refactoring support.

:::caution[Barrel Files]
We use barrel files (`index.ts`) only for public APIs, not for internal module organization. This prevents circular dependencies and keeps the module structure clear.
:::

## Code Style

We use Biome as our primary formatter and linter, with Prettier as a fallback for edge cases. Code is formatted with 2-space indentation, 120-character line limits, and trailing whitespace is enforced to be removed.

We always use semicolons in TypeScript code. The formatter decides quote style and trailing comma preferences to maintain consistency without bikeshedding.

## Rules

### Type Safety

1. TypeScript must be used in strict mode with all strict flags enabled
2. The `any` type is never allowed without explicit justification in code review
3. Non-null assertions (`!`) are never allowed
4. Use `interface` for object types and `type` for unions and complex compositions
5. Use `as const` assertions for literal types
6. Use TypeScript enums for fixed sets of related constants
7. Minimize type casting - solve type issues upstream instead

### Function Declarations

8. Use arrow functions for callbacks, traditional declarations for named top-level functions
9. Maximum function length is 50 lines

### Testing

10. All new code must have unit tests with minimum 80% coverage
11. Tests must be placed in `/tests` directory with `*.test.ts` naming
12. Follow Arrange-Act-Assert (AAA) pattern in all tests
13. Practice Test-Driven Development (TDD) strictly

### Error Handling

14. Use try-catch with custom error classes for error handling
15. Use async/await with try-catch for async error handling
16. Generic error messages for users, detailed logging for debugging

### Module Organization

17. Organize imports using auto-sorting tools
18. Use `@/` path aliases for imports
19. Barrel files only for public APIs

### Code Style

20. Use Biome for formatting and linting
21. 2-space indentation required
22. 120-character line limit
23. Always use semicolons
24. No use of biome-ignore comments to bypass linting issues

### Naming Conventions

25. Minimum variable names must be descriptive (no single-letter except loop indices)
26. Use snake_case for variables and functions
27. Use SCREAMING_SNAKE_CASE for constants
28. Use PascalCase for React components
29. Use Type suffix for types (UserType)
30. Use Props suffix for component props
31. Boolean variables should be descriptive without prefixes (active, permitted)

### Documentation

32. JSDoc required for complex functions only
33. Include @param and @returns in JSDoc documentation
34. Inline comments encouraged for complex logic only
35. No TODO/FIXME/HACK comments - use issue tracker
