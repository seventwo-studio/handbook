---
title: Go Coding Standards
---

## Overview

Go is used at SevenTwo Studio for performance-critical services and systems programming. We target the latest stable Go version and follow Go's idiomatic patterns and conventions. Our Go standards emphasize simplicity, explicit error handling, and leveraging the standard library.

## Project Layout

We follow the Standard Go Project Layout for organizing our Go projects. This widely-adopted structure includes directories like `cmd/` for application entry points, `pkg/` for library code, `internal/` for private packages, and `api/` for API definitions. This organization makes projects immediately familiar to Go developers.

## Modules and Dependencies

We use Go modules always for dependency management. Go modules provide reproducible builds, version selection, and proper dependency tracking. The `go.mod` and `go.sum` files are always committed to version control.

## Error Handling

Go's explicit error handling is one of its defining features. We always return and check errors explicitly rather than using panics or ignoring errors. We use custom error types to provide context and enable type-based error handling.

Error messages should be lowercase and not end with punctuation, following Go conventions. We wrap errors with additional context using `fmt.Errorf` with the `%w` verb to maintain the error chain.

## Web Framework

We use Chi router and the standard library for web services. Chi provides a lightweight, composable approach to HTTP routing while leveraging Go's excellent standard library HTTP support. For simpler services, the standard library alone is often sufficient.

## Testing

We use Go's standard library `testing` package for all tests. Go's testing approach is simple and effective without requiring heavy frameworks. We write table-driven tests for comprehensive test coverage with minimal code duplication.

Table-driven tests define test cases as data structures, making it easy to add new test cases and see all scenarios at a glance. This pattern is idiomatic in Go and scales well for complex testing requirements.

## Configuration

We handle configuration through environment variables and use viper for more complex configuration needs. Environment variables are simple, universally supported, and work well with containerized deployments. Viper provides additional flexibility for configuration files and advanced scenarios.

## Database Access

We use sqlx and pgx for database operations. Sqlx extends the standard library's `database/sql` with convenient features while maintaining compatibility. For PostgreSQL specifically, pgx provides better performance and PostgreSQL-specific features.

## Concurrency

We leverage Go's goroutines and channels for concurrent programming. Goroutines are lightweight and efficient. Channels provide safe communication between goroutines. We follow Go's concurrency mantra: "Share memory by communicating, don't communicate by sharing memory."

## Generics

We use generics where appropriate since their introduction in Go 1.18. Generics reduce code duplication for type-agnostic algorithms and data structures. However, we don't overuse them - explicit types are often clearer than generic code.

## Code Style and Linting

We use golangci-lint for comprehensive linting. Golangci-lint aggregates many Go linters and runs them efficiently. We use `gofmt` for code formatting, which is the standard Go formatter. Code that isn't `gofmt`'d will not pass CI.

## Code Organization

We keep packages focused and cohesive. Each package should have a clear purpose and minimal dependencies. We avoid circular dependencies and design packages to be independently testable.

## Rules

### Platform and Tooling

1. Target latest stable Go version
2. Use Go modules always for dependency management
3. Commit go.mod and go.sum to version control
4. Use golangci-lint for linting
5. Use gofmt for code formatting
6. All code must be gofmt'd before commit

### Project Structure

7. Follow Standard Go Project Layout (cmd/, pkg/, internal/, api/)
8. Keep packages focused and cohesive
9. Avoid circular dependencies

### Error Handling

10. Always return and check errors explicitly
11. Never ignore errors
12. Use custom error types for domain-specific errors
13. Error messages should be lowercase without ending punctuation
14. Wrap errors with context using fmt.Errorf with %w

### Web Framework

15. Use Chi router for web services
16. Standard library acceptable for simpler HTTP services

### Testing

17. Use standard library (testing) for all tests
18. Write table-driven tests for comprehensive coverage
19. Minimum 80% code coverage required
20. Practice Test-Driven Development (TDD) strictly
21. Tests required for all new code and bug fixes
22. Follow Arrange-Act-Assert (AAA) pattern in tests
23. Minimal mocking in tests - prefer real implementations

### Configuration

24. Use environment variables for configuration
25. Use viper for complex configuration needs

### Database Access

26. Use sqlx for database operations
27. Use pgx for PostgreSQL-specific needs

### Concurrency

28. Leverage goroutines for concurrent programming
29. Use channels for communication between goroutines

### Generics

30. Use generics where appropriate since Go 1.18+
31. Avoid overusing generics - explicit types often clearer

### Naming Conventions

32. Use snake_case for variables and functions
33. Use PascalCase for exported types and functions
34. Use SCREAMING_SNAKE_CASE for constants
35. Boolean variables should be descriptive without prefixes (active, permitted)
36. Maximum function length is 50 lines

### Documentation

37. JSDoc-style documentation required for complex functions only
38. Include parameter and return documentation for documented functions
39. No TODO/FIXME/HACK comments - use issue tracker
